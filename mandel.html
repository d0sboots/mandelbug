<!DOCTYPE html>
<html lang="en" style="overflow: clip">
  <head>
    <meta charset="utf-8">
    <link rel="modulepreload" href="mandel_worker.js">
    <title>Mandelbrot Viewer</title>
  </head>
  <body style="background: black; border: 0; margin: 0; height: 100%">
    <canvas id="canvas" style="touch-action: none"></canvas>
    <script>
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl2",
  {antialias: false, preserveDrawingBuffer: true});
let height = window.innerHeight;
let width = window.innerWidth;
let program;
const uniforms = {};
canvas.width = width;
canvas.height = height;
gl.viewport(0, 0, width, height);
let pointsPerCall = 100;
let pixelSize = 3 / Math.sqrt(width * height);
let cx = -0.75;
let cy = 0;
let dragLastX = 0;
let dragLastY = 0;
let zoom = 1;
let dx = 0;
let dy = 0;
let drawId = 0;
let lines;
const workers = [];
const workMsgCount = [];
const pending = new Map();

window.onresize = draw;

for (let i = 0; i < 4; ++i) {
  workers[i] = new Worker("mandel_worker.js", {type: "module"});
  workers[i].onmessage = handleMessage;
  workMsgCount[i] = 0;
}

canvas.addEventListener("pointerdown", (event) => {
  if (event.button !== 0) return;
  event.preventDefault();
  canvas.onpointermove = pointerMove;
  dragLastX = event.x;
  dragLastY = event.y;
  canvas.setPointerCapture(event.pointerId);
});
canvas.addEventListener("pointerup", (event) => {
  if (event.button !== 0) return;
  event.preventDefault();
  canvas.onpointermove = null;
  canvas.releasePointerCapture(event.pointerId);
});
canvas.addEventListener("wheel", wheel);

let raf = null;
function draw() {
  if (raf === null) {
    raf = requestAnimationFrame(animationFrame);
  }
}

initGL();
redraw();

function pointerMove(event) {
  dx += event.x - dragLastX;
  dy += event.y - dragLastY;
  dragLastX = event.x;
  dragLastY = event.y;
  draw();
}

function wheel(event) {
  const stepSize = ("wheelDelta" in event) ? event.wheelDelta / -120 : Math.sign(event.deltaY);
  const pxAdd = Math.expm1(stepSize * .133531392624522623); // 0.875^(-stepSize) - 1
  dx += zoom * pxAdd * (event.x - width / 2);
  dy += zoom * pxAdd * (event.y - height / 2);
  zoom += zoom * pxAdd;
  draw();
}

function* getLines() {
  let i = 0;
  const limit = width * height;
  const inc = 31337 % limit; // A large enough prime that we know width/height won't be a multiple of
  while (i < limit) {
    let coords = new Uint32Array(pointsPerCall | 0);
    for (let j = 0; j < (pointsPerCall | 0); j++) {
      coords[j] = i;
      i += inc;
      if (i >= limit) {
        if (i === limit) {
          coords = coords.subarray(0, j + 1);
          break;
        }
        i -= limit;
      }
    }

    drawId++;
    yield {cx, cy, drawId, width, height, pixelSize, maxIters: 1000000, coords};
  }
}

function initGL() {
  gl.clearColor(0.0, 0.0, 0.0, 1.0);
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);

  gl.enableVertexAttribArray(0);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(0, 2, gl.UNSIGNED_SHORT, false, 8, 0);
  gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, true, 8, 4);

  program = gl.createProgram();
  const vShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vShader, `#version 300 es
layout(location = 0) in vec2 coord;
layout(location = 1) in vec4 color;

uniform uint width;
uniform uint height;

out vec4 fColor;

void main() {
  vec2 transformed = (coord + 0.5) / (vec2(width, height) * 0.5) - 1.0;
  gl_Position = vec4(transformed.x, transformed.y, 0.0, 1.0);
  gl_PointSize = 1.0;
  fColor = color * 2.5;
}
  `);
  gl.compileShader(vShader);
  if (!gl.getShaderParameter(vShader, gl.COMPILE_STATUS)) {
    throw new Error('Unable to compile vertex shader:\n' + gl.getShaderInfoLog(vShader));
  }

  const fShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fShader, `#version 300 es
precision highp float;

in vec4 fColor;
out vec4 oColor;

void main() {
  oColor = fColor;
}
  `);
  gl.compileShader(fShader);
  if (!gl.getShaderParameter(fShader, gl.COMPILE_STATUS)) {
    throw new Error('Unable to compile fragment shader:\n' + gl.getShaderInfoLog(fShader));
  }

  gl.attachShader(program, vShader);
  gl.attachShader(program, fShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error("Could not link:\n" + gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);
  uniforms.width = gl.getUniformLocation(program, "width");
  uniforms.height = gl.getUniformLocation(program, "height");
  gl.uniform1ui(uniforms.width, width);
  gl.uniform1ui(uniforms.height, height);
}

function redraw() {
  lines = getLines();
  // Invalidate all current work
  for (const k of pending.keys()) {
    pending.set(k, false);
  }

  // Queue two units of work per worker, so that workers always have something to do.
  let i = -1;
  while (true) {
    do {
      i++;
      if (i >= workers.length * 2) return;
    } while (workMsgCount[i % workers.length] >= 2);
    handleMessage({target: workers[i % workers.length], data: {drawId: -1}});
  }
}

function handleMessage(msgEvent) {
  const workerIdx = workers.indexOf(msgEvent.target);
  // Can happen if we recreate workers to change pool size
  if (workerIdx < 0) return;

  const evalPerMs = msgEvent.data.evalPerMs;
  // Use exponential smoothing to mix in a new rate target.
  if (evalPerMs !== undefined) {
    pointsPerCall = (1 - 0.01) * pointsPerCall + 0.01 * 5 *
      (Number.isFinite(evalPerMs) ? evalPerMs : msgEvent.data.points.byteLength * 2);
  }
  const nextLine = lines.next();
  // The default state is each incoming message is balanced by a new outgoing
  // one, and workMsgCount is unchanged. We modify it when this is untrue.
  if (!nextLine.done) {
    const value = nextLine.value;
    pending.set(value.drawId, true);
    msgEvent.target.postMessage(value, [value.coords.buffer]);
  } else {
    workMsgCount[workerIdx]--;
  }
  const drawId = msgEvent.data.drawId;
  const active = pending.get(drawId);
  if (!pending.delete(drawId)) {
    // Item wasn't in map, no incoming message (this was a fake event to
    // enqueue new work)
    workMsgCount[workerIdx]++;
  }
  if (!active) return;

  const {points} = msgEvent.data;
  gl.bufferData(gl.ARRAY_BUFFER, points, gl.DYNAMIC_DRAW);
  gl.drawArrays(gl.POINTS, 0, (points.byteLength / 8) | 0);

  draw();
}

function animationFrame() {
  raf = null;
  const newWidth = window.innerWidth;
  const newHeight = window.innerHeight;
  if (newWidth !== width || newHeight !== height) {
    canvas.width = newWidth;
    canvas.height = newHeight;
    gl.viewport(0, 0, newWidth, newHeight);
    gl.uniform1ui(uniforms.width, newWidth);
    gl.uniform1ui(uniforms.height, newHeight);
  } else {
  }
  if (width === window.innerWidth && height === window.innerHeight &&
      dx === 0 && dy === 0 && zoom === 1) {
    return;
  }
  // Otherwise, we have to move and/or rescale the image.
  width = newWidth;
  height = newHeight;
  cx -= dx * pixelSize;
  cy -= dy * pixelSize;
  pixelSize *= zoom;
  dx = 0;
  dy = 0;
  zoom = 1;
  redraw();
}
    </script>
  </body>
</html>
