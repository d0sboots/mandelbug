<!DOCTYPE html>
<html lang="en" style="overflow: clip">
  <head>
    <meta charset="utf-8">
    <link rel="modulepreload" href="mandel_worker.js">
    <title>Mandelbrot Viewer</title>
  </head>
  <body style="background: black; border: 0; margin: 0; height: 100%">
    <canvas id="canvas" style="touch-action: none"></canvas>
    <script>
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl2",
  {antialias: false, preserveDrawingBuffer: true});
let height = window.innerHeight;
let width = window.innerWidth;
let program, programQuad;
let vao, vaoQuad;
const uniforms = {};
canvas.width = width;
canvas.height = height;
gl.viewport(0, 0, width, height);
let pointsPerCall = 100;
let pixelSize = 3 / Math.sqrt(width * height);
let cx = -0.75;
let cy = 0;
let dragLastX = 0;
let dragLastY = 0;
let zoom = 1;
let dx = 0;
let dy = 0;
let drawId = 0;
let lines;
const workers = [];
const workMsgCount = [];
const pending = new Map();

window.onresize = draw;

for (let i = 0; i < 4; ++i) {
  workers[i] = new Worker("mandel_worker.js", {type: "module"});
  workers[i].onmessage = handleMessage;
  workMsgCount[i] = 0;
}

canvas.addEventListener("pointerdown", (event) => {
  if (event.button !== 0) return;
  event.preventDefault();
  canvas.onpointermove = pointerMove;
  dragLastX = event.x;
  dragLastY = event.y;
  canvas.setPointerCapture(event.pointerId);
});
canvas.addEventListener("pointerup", (event) => {
  if (event.button !== 0) return;
  event.preventDefault();
  canvas.onpointermove = null;
  canvas.releasePointerCapture(event.pointerId);
});
canvas.addEventListener("wheel", wheel);

let raf = null;
function draw() {
  if (raf === null) {
    raf = requestAnimationFrame(animationFrame);
  }
}

initGL();
redraw();

function pointerMove(event) {
  dx += event.x - dragLastX;
  dy += event.y - dragLastY;
  dragLastX = event.x;
  dragLastY = event.y;
  draw();
}

function wheel(event) {
  const stepSize = ("wheelDelta" in event) ? event.wheelDelta / -120 : Math.sign(event.deltaY);
  const pxAdd = Math.expm1(stepSize * .133531392624522623); // 0.875^(-stepSize) - 1
  dx += zoom * pxAdd * (event.x - width / 2);
  dy += zoom * pxAdd * (event.y - height / 2);
  zoom += zoom * pxAdd;
  draw();
}

function* getLines() {
  let i = 0;
  const limit = width * height;
  const inc = 31337 % limit; // A large enough prime that we know width/height won't be a multiple of
  while (i < limit) {
    let coords = new Uint32Array(pointsPerCall | 0);
    for (let j = 0; j < (pointsPerCall | 0); j++) {
      coords[j] = i;
      i += inc;
      if (i >= limit) {
        if (i === limit) {
          coords = coords.subarray(0, j + 1);
          break;
        }
        i -= limit;
      }
    }

    drawId++;
    yield {cx, cy, drawId, width, height, pixelSize, maxIters: 1000000, coords};
  }
}

function initGL() {
  gl.clearColor(0.0, 0.0, 0.0, 1.0);

  const tex = gl.createTexture();
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  vaoQuad = gl.createVertexArray();
  gl.bindVertexArray(vaoQuad);
  const vboQuad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboQuad);
  gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array([0,0, 0,1, 1,1, 1,0]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 2, gl.UNSIGNED_BYTE, false, 0, 0);

  programQuad = gl.createProgram();
  const vShaderQuad = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vShaderQuad, `#version 300 es
layout(location = 0) in vec2 coord;

void main() {
  gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0);
}
  `);
  gl.compileShader(vShaderQuad);
  if (!gl.getShaderParameter(vShaderQuad, gl.COMPILE_STATUS)) {
    throw new Error('Unable to compile vertex shader:\n' + gl.getShaderInfoLog(vShaderQuad));
  }

  const fShaderQuad = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fShaderQuad, `#version 300 es
precision highp float;

uniform vec2 delta;
uniform vec2 zoom;
uniform sampler2D tex;

out vec4 color;

void main() {
  vec2 coord = vec2(gl_FragCoord) * zoom + delta;
  color = (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0) ?
      vec4(0) : texture(tex, coord);
}
  `);
  gl.compileShader(fShaderQuad);
  if (!gl.getShaderParameter(fShaderQuad, gl.COMPILE_STATUS)) {
    throw new Error('Unable to compile fragment shader:\n' + gl.getShaderInfoLog(fShaderQuad));
  }

  gl.attachShader(programQuad, vShaderQuad);
  gl.attachShader(programQuad, fShaderQuad);
  gl.linkProgram(programQuad);
  if (!gl.getProgramParameter(programQuad, gl.LINK_STATUS)) {
    throw new Error("Could not link:\n" + gl.getProgramInfoLog(programQuad));
  }
  uniforms.delta = gl.getUniformLocation(programQuad, "delta");
  uniforms.zoom = gl.getUniformLocation(programQuad, "zoom");
  uniforms.tex = gl.getUniformLocation(programQuad, "tex");

  vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.enableVertexAttribArray(0);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(0, 2, gl.UNSIGNED_SHORT, false, 8, 0);
  gl.vertexAttribPointer(1, 4, gl.UNSIGNED_BYTE, true, 8, 4);

  program = gl.createProgram();
  const vShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vShader, `#version 300 es
layout(location = 0) in vec2 coord;
layout(location = 1) in vec4 color;

uniform vec2 dim;

out vec4 fColor;

void main() {
  vec2 transformed = (coord + 0.5) / (dim * 0.5) - 1.0;
  gl_Position = vec4(transformed.x, transformed.y, 0.0, 1.0);
  gl_PointSize = 1.0;
  fColor = color * 2.5;
}
  `);
  gl.compileShader(vShader);
  if (!gl.getShaderParameter(vShader, gl.COMPILE_STATUS)) {
    throw new Error('Unable to compile vertex shader:\n' + gl.getShaderInfoLog(vShader));
  }

  const fShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fShader, `#version 300 es
precision highp float;

in vec4 fColor;
out vec4 oColor;

void main() {
  oColor = fColor;
}
  `);
  gl.compileShader(fShader);
  if (!gl.getShaderParameter(fShader, gl.COMPILE_STATUS)) {
    throw new Error('Unable to compile fragment shader:\n' + gl.getShaderInfoLog(fShader));
  }

  gl.attachShader(program, vShader);
  gl.attachShader(program, fShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    throw new Error("Could not link:\n" + gl.getProgramInfoLog(program));
  }
  gl.useProgram(program);
  uniforms.dim = gl.getUniformLocation(program, "dim");
  gl.uniform2fv(uniforms.dim, [width, height]);
}

function redraw() {
  lines = getLines();
  // Invalidate all current work
  for (const k of pending.keys()) {
    pending.set(k, false);
  }

  // Queue two units of work per worker, so that workers always have something to do.
  let i = -1;
  while (true) {
    do {
      i++;
      if (i >= workers.length * 2) return;
    } while (workMsgCount[i % workers.length] >= 2);
    handleMessage({target: workers[i % workers.length], data: {drawId: -1}});
  }
}

function handleMessage(msgEvent) {
  const workerIdx = workers.indexOf(msgEvent.target);
  // Can happen if we recreate workers to change pool size
  if (workerIdx < 0) return;

  const evalPerMs = msgEvent.data.evalPerMs;
  // Use exponential smoothing to mix in a new rate target.
  if (evalPerMs !== undefined) {
    pointsPerCall = (1 - 0.01) * pointsPerCall + 0.01 * 5 *
      (Number.isFinite(evalPerMs) ? evalPerMs : msgEvent.data.points.byteLength * 2);
  }
  const nextLine = lines.next();
  // The default state is each incoming message is balanced by a new outgoing
  // one, and workMsgCount is unchanged. We modify it when this is untrue.
  if (!nextLine.done) {
    const value = nextLine.value;
    pending.set(value.drawId, true);
    msgEvent.target.postMessage(value, [value.coords.buffer]);
  } else {
    workMsgCount[workerIdx]--;
  }
  const drawId = msgEvent.data.drawId;
  const active = pending.get(drawId);
  if (!pending.delete(drawId)) {
    // Item wasn't in map, no incoming message (this was a fake event to
    // enqueue new work)
    workMsgCount[workerIdx]++;
  }
  if (!active) return;

  const {points} = msgEvent.data;
  gl.bufferData(gl.ARRAY_BUFFER, points, gl.DYNAMIC_DRAW);
  gl.drawArrays(gl.POINTS, 0, (points.byteLength / 8) | 0);

  draw();
}

function animationFrame() {
  raf = null;
  const newWidth = window.innerWidth;
  const newHeight = window.innerHeight;
  const noRescale = width === newWidth && height === newHeight && zoom === 1;
  const isSimple = noRescale && dx === 0 && dy === 0;
  if (!isSimple) {
    gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, width, height, 0);
    if (noRescale) {
      // We can sample faster because there's no resize going on
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    }
  }
  if (newWidth !== width || newHeight !== height) {
    canvas.width = newWidth;
    canvas.height = newHeight;
    gl.viewport(0, 0, newWidth, newHeight);
  }
  if (isSimple) return;
  // Otherwise, we have to move and/or rescale the image.
  gl.useProgram(programQuad);
  gl.bindVertexArray(vaoQuad);
  // We are applying fragcoord * zoom + delta in the shader, so we have to
  // pre-multiply all our values here.
  // Input range is [0,0]-[newWidth, newHeight], output is (nominally) [0,0]-[1,1]
  gl.uniform2fv(uniforms.zoom, [zoom / width, zoom / height]);
  gl.uniform2fv(uniforms.delta, [
      (-dx - 0.5 * zoom * newWidth) / width + 0.5,
      (dy - 0.5 * zoom * newHeight) / height + 0.5]);
  gl.uniform1i(uniforms.tex, 0);
  gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
  gl.useProgram(program);
  gl.uniform2fv(uniforms.dim, [newWidth, newHeight]);
  gl.bindVertexArray(vao);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  width = newWidth;
  height = newHeight;
  cx -= dx * pixelSize;
  cy += dy * pixelSize;
  pixelSize *= zoom;
  dx = 0;
  dy = 0;
  zoom = 1;
  redraw();
}
    </script>
  </body>
</html>
